// HTTP 상태 코드 상수들의 긴 줄에 대한 ESLint max-len 경고 비활성화
/* eslint-disable max-len */


/**
 * HTTP(하이퍼텍스트 전송 프로토콜) 응답 상태 코드
 * @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}
 * 
 * 이 파일은 여기서 복사되었습니다: https://gist.github.com/scokmen/f813c904ef79022e84ab2409574d1b45
 */
enum HttpStatusCodes {

    /**
     * 서버가 요청 헤더를 받았으며 클라이언트는 요청 본문을 전송해야 합니다
     * (본문을 보내야 하는 요청의 경우, 예: POST 요청).
     * 부적절한 헤더로 인해 요청이 거부된 후 큰 요청 본문을 서버로 보내는 것은 비효율적입니다.
     * 서버가 요청의 헤더를 확인하도록 하려면, 클라이언트는 초기 요청에서 Expect: 100-continue를 헤더로 보내고
     * 본문을 보내기 전에 응답으로 100 Continue 상태 코드를 받아야 합니다. 417 Expectation Failed 응답은 요청을 계속하지 않아야 함을 나타냅니다.
     */
    CONTINUE = 100,

    /**
     * 요청자가 서버에 프로토콜 전환을 요청했고 서버가 이에 동의했습니다.
     */
    SWITCHING_PROTOCOLS = 101,

    /**
     * WebDAV 요청은 파일 작업과 관련된 많은 하위 요청을 포함할 수 있으며, 요청 완료에 긴 시간이 필요합니다.
     * 이 코드는 서버가 요청을 받았고 처리 중이지만 아직 응답이 준비되지 않았음을 나타냅니다.
     * 이는 클라이언트가 타임아웃되고 요청이 손실되었다고 가정하는 것을 방지합니다.
     */
    PROCESSING = 102,

    /**
     * 성공적인 HTTP 요청에 대한 표준 응답입니다.
     * 실제 응답은 사용된 요청 메서드에 따라 달라집니다.
     * GET 요청에서는 응답에 요청된 리소스에 해당하는 엔티티가 포함됩니다.
     * POST 요청에서는 응답에 작업 결과를 설명하거나 포함하는 엔티티가 포함됩니다.
     */
    OK = 200,

    /**
     * 요청이 충족되어 새로운 리소스가 생성되었습니다.
     */
    CREATED = 201,

    /**
     * 요청이 처리를 위해 수락되었지만 처리가 완료되지 않았습니다.
     * 요청은 결국 실행될 수도 있고 그렇지 않을 수도 있으며, 처리 중에 허용되지 않을 수 있습니다.
     */
    ACCEPTED = 202,

    /**
     * HTTP/1.1부터
     * 서버는 원본에서 200 OK를 받은 변환 프록시이지만,
     * 원본 응답의 수정된 버전을 반환하고 있습니다.
     */
    NON_AUTHORITATIVE_INFORMATION = 203,

    /**
     * 서버가 요청을 성공적으로 처리했지만 콘텐츠를 반환하지 않습니다.
     */
    NO_CONTENT = 204,

    /**
     * 서버가 요청을 성공적으로 처리했지만 콘텐츠를 반환하지 않습니다.
     * 204 응답과 달리, 이 응답은 요청자가 문서 뷰를 재설정하도록 요구합니다.
     */
    RESET_CONTENT = 205,

    /**
     * 클라이언트가 보낸 범위 헤더로 인해 서버가 리소스의 일부만 제공합니다(바이트 서빙).
     * 범위 헤더는 HTTP 클라이언트가 중단된 다운로드를 재개하거나
     * 다운로드를 여러 동시 스트림으로 분할할 수 있도록 하는 데 사용됩니다.
     */
    PARTIAL_CONTENT = 206,

    /**
     * 뒤따르는 메시지 본문은 XML 메시지이며 수행된 하위 요청 수에 따라
     * 여러 개의 별도 응답 코드를 포함할 수 있습니다.
     */
    MULTI_STATUS = 207,

    /**
     * DAV 바인딩의 멤버들이 이미 (다중 상태) 응답의 이전 부분에서 열거되었으며,
     * 다시 포함되지 않습니다.
     */
    ALREADY_REPORTED = 208,

    /**
     * 서버가 리소스에 대한 요청을 충족했으며,
     * 응답은 현재 인스턴스에 적용된 하나 이상의 인스턴스 조작 결과의 표현입니다.
     */
    IM_USED = 226,

    /**
     * 클라이언트가 선택할 수 있는 리소스에 대한 여러 옵션을 나타냅니다(에이전트 주도 콘텐츠 협상을 통해).
     * 예를 들어, 이 코드는 여러 비디오 형식 옵션을 제시하거나,
     * 다른 파일 이름 확장자를 가진 파일을 나열하거나, 단어 의미 명확화를 제안하는 데 사용될 수 있습니다.
     */
    MULTIPLE_CHOICES = 300,

    /**
     * 이 요청과 향후 모든 요청은 주어진 URI로 전달되어야 합니다.
     */
    MOVED_PERMANENTLY = 301,

    /**
     * 이것은 표준에 반하는 업계 관행의 예입니다.
     * HTTP/1.0 사양(RFC 1945)에서는 클라이언트가 임시 리다이렉트를 수행하도록 요구했지만
     * (원래 설명 문구는 "Moved Temporarily"였음), 인기 있는 브라우저들은 302를
     * 303 See Other의 기능으로 구현했습니다. 따라서 HTTP/1.1은 두 동작을 구별하기 위해
     * 상태 코드 303과 307을 추가했습니다. 그러나 일부 웹 애플리케이션과 프레임워크는
     * 302 상태 코드를 303인 것처럼 사용합니다.
     */
    FOUND = 302,

    /**
     * HTTP/1.1부터
     * 요청에 대한 응답은 GET 메서드를 사용하여 다른 URI에서 찾을 수 있습니다.
     * POST(또는 PUT/DELETE)에 대한 응답으로 수신되면, 클라이언트는
     * 서버가 데이터를 받았다고 가정하고 별도의 GET 메시지로 리다이렉트를 발행해야 합니다.
     */
    SEE_OTHER = 303,

    /**
     * If-Modified-Since 또는 If-None-Match 요청 헤더에 지정된 버전 이후로 리소스가 수정되지 않았음을 나타냅니다.
     * 이 경우 클라이언트가 이전에 다운로드한 사본을 여전히 가지고 있으므로 리소스를 다시 전송할 필요가 없습니다.
     */
    NOT_MODIFIED = 304,

    /**
     * HTTP/1.1부터
     * 요청된 리소스는 프록시를 통해서만 사용할 수 있으며, 그 주소가 응답에 제공됩니다.
     * 많은 HTTP 클라이언트(Mozilla 및 Internet Explorer 등)는 주로 보안상의 이유로 이 상태 코드에 대한 응답을 올바르게 처리하지 않습니다.
     */
    USE_PROXY = 305,

    /**
     * 더 이상 사용되지 않습니다. 원래는 "후속 요청은 지정된 프록시를 사용해야 함"을 의미했습니다.
     */
    SWITCH_PROXY = 306,

    /**
     * HTTP/1.1부터
     * 이 경우 요청은 다른 URI로 반복되어야 하지만, 향후 요청은 여전히 원래 URI를 사용해야 합니다.
     * 302가 역사적으로 구현된 방식과 달리, 원래 요청을 다시 발행할 때 요청 메서드를 변경할 수 없습니다.
     * 예를 들어, POST 요청은 다른 POST 요청을 사용하여 반복되어야 합니다.
     */
    TEMPORARY_REDIRECT = 307,

    /**
     * 요청과 향후 모든 요청은 다른 URI를 사용하여 반복되어야 합니다.
     * 307과 308은 302와 301의 동작과 유사하지만, HTTP 메서드 변경을 허용하지 않습니다.
     * 따라서 예를 들어, 영구적으로 리다이렉트된 리소스에 양식을 제출하는 것이 원활하게 계속될 수 있습니다.
     */
    PERMANENT_REDIRECT = 308,

    /**
     * 명백한 클라이언트 오류로 인해 서버가 요청을 처리할 수 없거나 처리하지 않습니다
     * (예: 잘못된 요청 구문, 너무 큰 크기, 잘못된 요청 메시지 프레이밍 또는 기만적인 요청 라우팅).
     */
    BAD_REQUEST = 400,

    /**
     * 403 Forbidden과 유사하지만, 인증이 필요하고 실패했거나 아직 제공되지 않은 경우에 특별히 사용됩니다.
     * 응답에는 요청된 리소스에 적용 가능한 챌린지가 포함된 WWW-Authenticate 헤더 필드가 포함되어야 합니다.
     * 기본 액세스 인증 및 다이제스트 액세스 인증을 참조하세요. 401은 의미상 "인증되지 않음"을 의미합니다.
     * 즉, 사용자가 필요한 자격 증명을 가지고 있지 않습니다.
     */
    UNAUTHORIZED = 401,

    /**
     * 향후 사용을 위해 예약되었습니다. 원래 의도는 이 코드가 디지털 현금이나 소액 결제 체계의 일부로
     * 사용될 수 있다는 것이었지만, 그렇게 되지 않았고 이 코드는 일반적으로 사용되지 않습니다.
     * Google Developers API는 특정 개발자가 일일 요청 한도를 초과한 경우 이 상태를 사용합니다.
     */
    PAYMENT_REQUIRED = 402,

    /**
     * 요청은 유효했지만 서버가 작업을 거부하고 있습니다.
     * 사용자가 리소스에 대한 필요한 권한을 가지고 있지 않을 수 있습니다.
     */
    FORBIDDEN = 403,

    /**
     * 요청된 리소스를 찾을 수 없지만 향후에는 사용할 수 있을 수 있습니다.
     * 클라이언트의 후속 요청은 허용됩니다.
     */
    NOT_FOUND = 404,

    /**
     * 요청 메서드가 요청된 리소스에 대해 지원되지 않습니다.
     * 예를 들어, POST를 통해 데이터를 제출해야 하는 양식에 대한 GET 요청, 또는 읽기 전용 리소스에 대한 PUT 요청.
     */
    METHOD_NOT_ALLOWED = 405,

    /**
     * 요청된 리소스는 요청에서 보낸 Accept 헤더에 따라 허용되지 않는 콘텐츠만 생성할 수 있습니다.
     */
    NOT_ACCEPTABLE = 406,

    /**
     * 클라이언트는 먼저 프록시로 인증해야 합니다.
     */
    PROXY_AUTHENTICATION_REQUIRED = 407,

    /**
     * 서버가 요청을 기다리는 동안 시간이 초과되었습니다.
     * HTTP 사양에 따르면:
     * "클라이언트가 서버가 기다릴 준비가 된 시간 내에 요청을 생성하지 않았습니다. 클라이언트는 나중에 언제든지 수정 없이 요청을 반복할 수 있습니다."
     */
    REQUEST_TIMEOUT = 408,

    /**
     * 여러 동시 업데이트 간의 편집 충돌과 같이 요청의 충돌로 인해 요청을 처리할 수 없음을 나타냅니다.
     */
    CONFLICT = 409,

    /**
     * 요청된 리소스가 더 이상 사용할 수 없으며 다시 사용할 수 없음을 나타냅니다.
     * 리소스가 의도적으로 제거되었고 리소스를 제거해야 할 때 사용해야 합니다.
     * 410 상태 코드를 받으면 클라이언트는 향후 리소스를 요청하지 않아야 합니다.
     * 검색 엔진과 같은 클라이언트는 인덱스에서 리소스를 제거해야 합니다.
     * 대부분의 사용 사례에서는 클라이언트와 검색 엔진이 리소스를 제거할 필요가 없으며, 대신 "404 Not Found"를 사용할 수 있습니다.
     */
    GONE = 410,

    /**
     * 요청이 요청된 리소스에서 요구하는 콘텐츠의 길이를 지정하지 않았습니다.
     */
    LENGTH_REQUIRED = 411,

    /**
     * 서버가 요청자가 요청에 설정한 전제 조건 중 하나를 충족하지 않습니다.
     */
    PRECONDITION_FAILED = 412,

    /**
     * 요청이 서버가 기꺼이 또는 처리할 수 있는 것보다 큽니다. 이전에는 "Request Entity Too Large"라고 불렸습니다.
     */
    PAYLOAD_TOO_LARGE = 413,

    /**
     * 제공된 URI가 서버가 처리하기에 너무 깁니다. 종종 GET 요청의 쿼리 문자열로 너무 많은 데이터가 인코딩된 결과이며,
     * 이 경우 POST 요청으로 변환되어야 합니다.
     * 이전에는 "Request-URI Too Long"이라고 불렸습니다.
     */
    URI_TOO_LONG = 414,

    /**
     * 요청 엔티티의 미디어 타입이 서버나 리소스에서 지원하지 않습니다.
     * 예를 들어, 클라이언트가 이미지를 image/svg+xml로 업로드했지만 서버에서 이미지가 다른 형식을 사용하도록 요구하는 경우.
     */
    UNSUPPORTED_MEDIA_TYPE = 415,

    /**
     * 클라이언트가 파일의 일부(바이트 서빙)를 요청했지만 서버가 해당 부분을 제공할 수 없습니다.
     * 예를 들어, 클라이언트가 파일 끝을 넘어서는 파일의 일부를 요청한 경우.
     * 이전에는 "Requested Range Not Satisfiable"이라고 불렸습니다.
     */
    RANGE_NOT_SATISFIABLE = 416,

    /**
     * 서버가 Expect 요청 헤더 필드의 요구 사항을 충족할 수 없습니다.
     */
    EXPECTATION_FAILED = 417,

    /**
     * 이 코드는 1998년 RFC 2324, Hyper Text Coffee Pot Control Protocol에서 전통적인 IETF 만우절 농담 중 하나로 정의되었으며,
     * 실제 HTTP 서버에서 구현될 것으로 예상되지 않습니다. RFC는 이 코드가
     * 커피를 우려달라는 요청을 받은 주전자에서 반환되어야 한다고 명시합니다. 이 HTTP 상태는 Google.com을 포함한 일부 웹사이트에서 이스터 에그로 사용됩니다.
     */
    I_AM_A_TEAPOT = 418,

    /**
     * 요청이 응답을 생성할 수 없는 서버로 전달되었습니다(예: 연결 재사용으로 인해).
     */
    MISDIRECTED_REQUEST = 421,

    /**
     * 요청은 잘 구성되었지만 의미상 오류로 인해 따를 수 없었습니다.
     */
    UNPROCESSABLE_ENTITY = 422,

    /**
     * 액세스되고 있는 리소스가 잠겨 있습니다.
     */
    LOCKED = 423,

    /**
     * 이전 요청의 실패로 인해 요청이 실패했습니다(예: PROPPATCH).
     */
    FAILED_DEPENDENCY = 424,

    /**
     * 클라이언트는 Upgrade 헤더 필드에 주어진 TLS/1.0과 같은 다른 프로토콜로 전환해야 합니다.
     */
    UPGRADE_REQUIRED = 426,

    /**
     * 원본 서버에서 요청이 조건부가 되도록 요구합니다.
     * "클라이언트가 리소스의 상태를 GET하고, 수정한 다음, 서버에 PUT으로 되돌려 보내는데,
     * 그 사이에 제3자가 서버의 상태를 수정하여 충돌이 발생하는 '분실된 업데이트' 문제"를 방지하기 위한 것입니다.
     */
    PRECONDITION_REQUIRED = 428,

    /**
     * 사용자가 주어진 시간 내에 너무 많은 요청을 보냈습니다. 속도 제한 체계와 함께 사용하기 위한 것입니다.
     */
    TOO_MANY_REQUESTS = 429,

    /**
     * 개별 헤더 필드 또는 모든 헤더 필드가 집합적으로 너무 크기 때문에
     * 서버가 요청을 처리하기를 꺼립니다.
     */
    REQUEST_HEADER_FIELDS_TOO_LARGE = 431,

    /**
     * 서버 운영자가 요청된 리소스를 포함하는 리소스 또는 리소스 집합에 대한 액세스를 거부하라는 법적 요구를 받았습니다.
     * 코드 451은 소설 화씨 451에 대한 참조로 선택되었습니다.
     */
    UNAVAILABLE_FOR_LEGAL_REASONS = 451,

    /**
     * 예상치 못한 조건이 발생했고 더 구체적인 메시지가 적절하지 않을 때 주어지는 일반적인 오류 메시지입니다.
     */
    INTERNAL_SERVER_ERROR = 500,

    /**
     * 서버가 요청 메서드를 인식하지 못하거나 요청을 충족할 능력이 없습니다.
     * 일반적으로 이는 향후 가용성을 의미합니다(예: 웹 서비스 API의 새로운 기능).
     */
    NOT_IMPLEMENTED = 501,

    /**
     * 서버가 게이트웨이나 프록시 역할을 하고 있었고 업스트림 서버로부터 잘못된 응답을 받았습니다.
     */
    BAD_GATEWAY = 502,

    /**
     * 서버가 현재 사용할 수 없습니다(과부하 또는 유지보수로 인해 중단됨).
     * 일반적으로 이는 임시적인 상태입니다.
     */
    SERVICE_UNAVAILABLE = 503,

    /**
     * 서버가 게이트웨이나 프록시 역할을 하고 있었고 업스트림 서버로부터 시기적절한 응답을 받지 못했습니다.
     */
    GATEWAY_TIMEOUT = 504,

    /**
     * 서버가 요청에 사용된 HTTP 프로토콜 버전을 지원하지 않습니다.
     */
    HTTP_VERSION_NOT_SUPPORTED = 505,

    /**
     * 요청에 대한 투명한 콘텐츠 협상이 순환 참조를 발생시킵니다.
     */
    VARIANT_ALSO_NEGOTIATES = 506,

    /**
     * 서버가 요청을 완료하는 데 필요한 표현을 저장할 수 없습니다.
     */
    INSUFFICIENT_STORAGE = 507,

    /**
     * 서버가 요청을 처리하는 동안 무한 루프를 감지했습니다.
     */
    LOOP_DETECTED = 508,

    /**
     * 서버가 요청을 충족하려면 요청에 대한 추가 확장이 필요합니다.
     */
    NOT_EXTENDED = 510,

    /**
     * 클라이언트가 네트워크 액세스를 얻으려면 인증해야 합니다.
     * 네트워크에 대한 액세스를 제어하는 데 사용되는 차단 프록시에서 사용하기 위한 것입니다
     * (예: Wi-Fi 핫스팟을 통해 전체 인터넷 액세스를 허용하기 전에 서비스 약관에 동의하도록 요구하는 데 사용되는 "캡티브 포털").
     */
    NETWORK_AUTHENTICATION_REQUIRED = 511
}


/******************************************************************************
                            기본 내보내기
******************************************************************************/

export default HttpStatusCodes;
